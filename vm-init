#!/bin/bash
# SPDX-License-Identifier: GPL-2.0
#
# vm-init: actual init script
#
# Copyright (C) 2019 Vitaly Chikunov <vt@altlinux.org>
#

export PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/sbin:/usr/local/bin

mount -t proc -o nosuid,noexec,nodev proc /proc
read -r cmdline < /proc/cmdline
if [ -z "${cmdline/* VERBOSE=1*}" ]; then
	V=-v
	V() { echo "- $@"; "$@"; }
else
	V=
	V() { "$@"; }
fi

V mount -t tmpfs tmpfs /tmp
V mount -t tmpfs tmpfs /var/log
V mount -t sysfs -o nosuid,noexec,nodev sys /sys

V mount -t devtmpfs -o mode=0755,nosuid,noexec devtmpfs /dev
ln -sf /proc/kcore     /dev/core
ln -sf /proc/self/fd   /dev/fd
ln -sf /proc/self/fd/0 /dev/stdin
ln -sf /proc/self/fd/1 /dev/stdout
ln -sf /proc/self/fd/2 /dev/stderr

V mount -t configfs configfs /sys/kernel/config
V mount -t debugfs debugfs /sys/kernel/debug
V mount -t securityfs securityfs /sys/kernel/security

mkdir -p /dev/pts /dev/shm
V mount -t devpts -o gid=tty,mode=620,noexec,nosuid devpts /dev/pts
V mount -t tmpfs -o mode=1777,nosuid,nodev tmpfs /dev/shm

V ip link set dev lo up 2>/dev/null

if grep -q UDEVD=y /proc/cmdline; then
	V udevd --daemon --resolve-names=never
	V udevadm trigger --type=subsystems --action=add
	V udevadm trigger --type=devices --action=add
	V udevadm settle
else
	# try to load some modules
	V modprobe --all virtio_blk scsi_mod ata_piix pata_acpi ata_generic sd_mod
fi
V modprobe virtio_rng

# test writability
if tmp=$(mktemp -p /usr/src 2>/dev/null); then
	rm $tmp
else
	echo "***************************************************"
	echo "*  Error: Impossible to create files in /usr/src  *"
	echo "*         Exit code from qemu cmd will be lost!   *"
	echo "***************************************************"
fi

# Handle --overlay option
UMOUNT=
ov_count=0
img_count=0
prev_cmdline=$cmdline
while [ -z "${prev_cmdline/* OVERLAY=*}" ]; do
	prev_cmdline=${prev_cmdline#* OVERLAY=}
	OVERLAY=${prev_cmdline%% *}
	IFS=: read ovfs ovpath <<< "$OVERLAY"
	IFS=, read ovfs ovopts <<< "$ovfs"
	mnt=/mnt/$ov_count
	ov_count=$((ov_count+1))
	mkdir -p $mnt
	if [ -b "$ovfs" ]; then
		# full device path
		V mount $V -n "$ovfs" $mnt
	elif [ -b "/dev/$ovfs" ]; then
		# short device name
		V mount $V -n "/dev/$ovfs" $mnt
	elif [ -d "$ovfs" ]; then
		# use existing dir
		mnt=$ovfs
	elif [ "$ovfs" = tmpfs ]; then
		# auto-create tmpfs mount
		V mount $V -t tmpfs ${ovopts:+-o $ovopts} tmpfs $mnt
	elif [ "$ovfs" = ext4 ]; then
		# auto-create ext4 partition
		size=${ovopts#*size=}
		size=${size%%,*}
		img=/usr/src/ext4.$img_count.img
		# do not delete data if it already exists
		if ! /sbin/tune2fs -l $img >/dev/null 2>&1; then
			> $img
			V truncate -s ${size:-11M} $img
			V /sbin/mkfs.ext4 -q $img
		fi
		V mount $V -t ext4 -o loop $img $mnt
		img_count=$((img_count+1))
	else
		echo "Unknown how to overlay $OVERLAY"
		unset mnt
	fi
	if [ "$mnt" ]; then
		mkdir -p $mnt/upper $mnt/work
		: ${ovpath:=/usr/src}
		V mount $V -t overlay -olowerdir=$ovpath,upperdir=$mnt/upper,workdir=$mnt/work overlay $ovpath
		UMOUNT=$ovpath
	fi
	unset mnt ovfs ovopts ovpath
done
unset ov_count img_count prev_cmdline

SCRIPT=${cmdline#* SCRIPT=}
SCRIPT=${SCRIPT%% *}
setsid --ctty --wait $SCRIPT
RET=$?

[ "$UMOUNT" ] && umount $V -n --lazy $UMOUNT
echo $RET 2>/dev/null > $SCRIPT.ret ||
	echo Exit code $RET is lost

# Disable `reboot: Power down' message
[ -z "${cmdline/* quiet *}" ] && echo 0 > /proc/sys/kernel/printk

V poweroff -f
